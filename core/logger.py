# ------------------------------------------------------------
# Logging and LaTeX Export (clean formatted proof)
# ------------------------------------------------------------
from .proof_kernel import ProofStep


def export_latex(steps: list[ProofStep], goal: str = "1Â·(u+v)=u+v") -> str:
    """
    Export a readable LaTeX proof:
    - Clean title and goal formatting
    - Numbered steps with rule change separation
    - Rule shown neatly on the right
    - Proper brace escaping for f-strings
    """
    lines = []

    # ------------------- LaTeX Document Setup (Based on original file structure) ------------------
    # NOTE: These lines must be present for the file to compile if they are not in latex_export.py
    lines.append(r"\documentclass[12pt]{article}")
    lines.append(r"\usepackage{amsmath, amssymb, xcolor}")
    lines.append(r"\usepackage[margin=1in]{geometry}")
    lines.append(r"\setlength{\parindent}{0pt}")
    lines.append(r"\setlength{\parskip}{0.5em}")
    lines.append(r"\begin{document}")

    # ------------------- Title & Metadata -------------------
    lines.append(r"\begin{center}")
    lines.append(r"\Large\textbf{Vector Space Proof Demonstration}\\[0.5em]")
    lines.append(r"\normalsize\textit{Generated by the Khwarizmi Symbolic System}\\[1em]")
    lines.append(r"\end{center}")

    # ------------------- Header & Goal ------------------
    # The GOAL LINE that works for your environment:
    safe_goal_expr = goal.replace("_", r"\_")
    lines.append(r"\textbf{Goal:} Prove that $" + safe_goal_expr + r"$\\\\[1em]")

    # Start the alignment environment for the proof steps
    lines.append(r"\begin{alignat*}{2}")
    
    # Use the first step's 'before' expression for the start line
    if steps:
        lines.append(r"& \text{Start:} \quad " + steps[0].before.to_latex() + r"\\")


    # ------------------- Step Loop -------------------
    step_counter = 0 # Initialize at 0 so the first major step is (1)
    sub_counter = 0
    last_rule = None

    for s in [s for s in steps if s.status == "ok"]:
        before = s.before.to_latex()
        after = s.after.to_latex()
        rule = s.rule.replace("_", r"\_")
        
        # Detect major rule change and add separator
        if s.rule != last_rule and step_counter > 0:
            # ADD SEPARATION LINE HERE:
            lines.append(r"\noalign{\vskip 0.5em\hrule height 0.4pt \vskip 0.5em}")
        
        # Detect same-rule chaining for substeps
        if s.rule == last_rule:
            label = f"{step_counter}{chr(96 + sub_counter)}"  # e.g., 1a, 1b
            sub_counter += 1
        else:
            step_counter += 1
            sub_counter = 1
            label = f"{step_counter}"
            last_rule = s.rule

        # Normal step
        # Note: Using the rule name as justification
        lines.append(
            f"({label})\\;& {before} = {after} "
            f"& \\quad\\textcolor{{gray}}{{[{rule}]}} \\\\"
        )

    # ------------------- Conclusion -------------------
    if steps:
        # Final proof is the last expression in the trace
        final_expr_latex = steps[-1].after.to_latex()
        
        # Add final separator line
        lines.append(r"\noalign{\vskip 0.5em\hrule height 0.4pt \vskip 0.5em}")
        lines.append(r"\\")
        
        # Final Result Line
        lines.append(
            r"& \text{Final Result:} \quad "
            + final_expr_latex
            + r"\\ "
        )
        lines.append(r"\\")
        
        # Q.E.D.
        lines.append(
            r"& \textbf{Q.E.D.}"
        )
        lines.append(r"\\")
    
    lines.append(r"\end{alignat*}")
    
    # ------------------- Document Footer -------------------
    lines.append(r"\end{document}")
    
    return "\n".join(lines)